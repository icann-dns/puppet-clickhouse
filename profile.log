FUNCTION  <SNR>52_exec_separator()
Called 28 times
Total time:   0.014348
 Self time:   0.001072

count  total (s)   self (s)
   28              0.000043   if pumvisible()
                                return
                              endif
   28   0.003695   0.000168   let l:from = airline#themes#get_highlight(a:from.a:suffix)
   28   0.003651   0.000156   let l:to = airline#themes#get_highlight(a:to.a:suffix)
   28              0.000099   let group = a:from.'_to_'.a:to.a:suffix
   28              0.000032   if a:inverse
    8              0.000039     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
    8              0.000005   else
   20              0.000098     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   20              0.000013   endif
   28              0.000076   let a:dict[group] = colors
   28   0.006426   0.000172   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>33_Highlight_Matching_Pair()
Called 11 times
Total time:   0.001366
 Self time:   0.001366

count  total (s)   self (s)
                              " Remove any previous match.
   11              0.000072   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   11              0.000058   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   11              0.000037   let c_lnum = line('.')
   11              0.000030   let c_col = col('.')
   11              0.000013   let before = 0
                            
   11              0.000037   let text = getline(c_lnum)
   11              0.000350   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   11              0.000041   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
   11              0.000055     let [c_before, c] = matches[1:2]
   11              0.000008   endif
   11              0.000231   let plist = split(&matchpairs, '.\zs[:,]')
   11              0.000042   let i = index(plist, c)
   11              0.000015   if i < 0
                                " not found, in Insert mode try character before the cursor
   11              0.000047     if c_col > 1 && (mode() == 'i' || mode() == 'R')
    8              0.000022       let before = strlen(c_before)
    8              0.000009       let c = c_before
    8              0.000018       let i = index(plist, c)
    8              0.000005     endif
   11              0.000011     if i < 0
                                  " not found, nothing to do
   11              0.000012       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  airline#parts#filetype()
Called 14 times
Total time:   0.000284
 Self time:   0.000284

count  total (s)   self (s)
   14              0.000276   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  38()
Called 28 times
Total time:   0.001220
 Self time:   0.001220

count  total (s)   self (s)
   28              0.000378     let newObj = copy(self)
                            
   28              0.000152     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
                            
   28              0.000064     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
   28              0.000076     let newObj._rawLoclist = llist
   28              0.000050     let newObj._name = ''
   28              0.000077     let newObj._owner = bufnr('')
   28              0.000045     let newObj._sorted = 0
   28              0.000068     let newObj._columns = g:syntastic_cursor_columns
                            
   28              0.000035     return newObj

FUNCTION  39()
Called 28 times
Total time:   0.002247
 Self time:   0.000825

count  total (s)   self (s)
   28              0.000106     let buf = a:0 ? a:1 : bufnr('')
   28   0.000424   0.000222     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
   28              0.000137     if type(loclist) != type({}) || empty(loclist)
   28              0.000055         unlet! loclist
   28   0.001415   0.000195         let loclist = g:SyntasticLoclist.New([])
   28              0.000024     endif
   28              0.000029     return loclist

FUNCTION  airline#highlighter#highlight()
Called 2 times
Total time:   0.049359
 Self time:   0.005937

count  total (s)   self (s)
    2              0.000006   let bufnr = a:0 ? a:1 : ''
    2              0.000008   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    2              0.000026   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    2              0.000006   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    6              0.000009   for mode in mapped
    4              0.000012     if mode == 'inactive' && winnr('$') == 1
                                  " there exist no inactive windows, don't need to create all those
                                  " highlighting groups
                                  continue
                                endif
    4              0.000025     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    4              0.000016       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
   40              0.000099       for kvp in items(dict)
   36              0.000102         let mode_colors = kvp[1]
   36              0.000079         let name = kvp[0]
   36              0.000114         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
                                    endif
   36   0.009911   0.000287         call airline#highlighter#exec(name.suffix, mode_colors)
                            
  108              0.000270         for accent in keys(s:accents)
   72              0.000217           if !has_key(p.accents, accent)
                                        continue
                                      endif
   72              0.000282           let colors = copy(mode_colors)
   72              0.000246           if p.accents[accent][0] != ''
   36              0.000107             let colors[0] = p.accents[accent][0]
   36              0.000029           endif
   72              0.000159           if p.accents[accent][2] != ''
   36              0.000108             let colors[2] = p.accents[accent][2]
   36              0.000028           endif
   72              0.000145           if len(colors) >= 5
   72              0.000301             let colors[4] = get(p.accents[accent], 4, '')
   72              0.000058           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
   72   0.020126   0.000676           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
   72              0.000113         endfor
   36              0.000042       endfor
                            
                                  " TODO: optimize this
   32              0.000079       for sep in items(s:separators)
   28   0.014632   0.000284         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   28              0.000026       endfor
    4              0.000005     endif
    4              0.000003   endfor

FUNCTION  airline#parts#mode()
Called 14 times
Total time:   0.000448
 Self time:   0.000171

count  total (s)   self (s)
   14   0.000440   0.000163   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  48()
Called 28 times
Total time:   0.002106
 Self time:   0.002106

count  total (s)   self (s)
   28              0.000083     if !exists('self._stl_format')
   28              0.000053         let self._stl_format = ''
   28              0.000023     endif
   28              0.000070     if !exists('self._stl_flag')
   28              0.000048         let self._stl_flag = ''
   28              0.000017     endif
                            
   28              0.000062     if g:syntastic_stl_format !=# self._stl_format
   28              0.000054         let self._stl_format = g:syntastic_stl_format
                            
   28              0.000058         if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
                                    else
   28              0.000046             let self._stl_flag = ''
   28              0.000022         endif
   28              0.000017     endif
                            
   28              0.000034     return self._stl_flag

FUNCTION  <SNR>43_IsInString()
Called 2 times
Total time:   0.000460
 Self time:   0.000460

count  total (s)   self (s)
    2              0.000459   return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_string

FUNCTION  airline#statusline()
Called 14 times
Total time:   0.000252
 Self time:   0.000252

count  total (s)   self (s)
   14              0.000118   if has_key(s:contexts, a:winnr)
   14              0.000106     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  GetRubyIndent()
Called 2 times
Total time:   0.029759
 Self time:   0.001174

count  total (s)   self (s)
                              " 3.1. Setup {{{2
                              " ----------
                            
                              " The value of a single shift-width
    2              0.000018   let sw = shiftwidth()
                            
                              " For the current line, use the first argument if given, else v:lnum
    2              0.000005   let clnum = a:0 ? a:1 : v:lnum
                            
                              " Set up variables for restoring position in file.  Could use clnum here.
    2              0.000009   let vcol = col('.')
                            
                              " 3.2. Work on the current line {{{2
                              " -----------------------------
                            
                              " Get the current line.
    2              0.000007   let line = getline(clnum)
    2              0.000003   let ind = -1
                            
                              " If this line is an access modifier keyword, align according to the closest
                              " class declaration.
    2              0.000006   if g:ruby_indent_access_modifier_style == 'indent'
                                if s:Match(clnum, s:access_modifier_regex)
                                  let class_line = s:FindContainingClass()
                                  if class_line > 0
                                    return indent(class_line) + sw
                                  endif
                                endif
                              elseif g:ruby_indent_access_modifier_style == 'outdent'
                                if s:Match(clnum, s:access_modifier_regex)
                                  let class_line = s:FindContainingClass()
                                  if class_line > 0
                                    return indent(class_line)
                                  endif
                                endif
                              endif
                            
                              " If we got a closing bracket on an empty line, find its match and indent
                              " according to it.  For parentheses we indent to its column - 1, for the
                              " others we indent to the containing line's MSL's level.  Return -1 if fail.
    2              0.000041   let col = matchend(line, '^\s*[]})]')
    2              0.000007   if col > 0 && !s:IsInStringOrComment(clnum, col)
                                call cursor(clnum, col)
                                let bs = strpart('(){}[]', stridx(')}]', line[col - 1]) * 2, 2)
                                if searchpair(escape(bs[0], '\['), '', bs[1], 'bW', s:skip_expr) > 0
                                  if line[col-1]==')' && col('.') != col('$') - 1
                                    let ind = virtcol('.') - 1
                                  elseif g:ruby_indent_block_style == 'do'
                                    let ind = indent(line('.'))
                                  else " g:ruby_indent_block_style == 'expression'
                                    let ind = indent(s:GetMSL(line('.')))
                                  endif
                                endif
                                return ind
                              endif
                            
                              " If we have a =begin or =end set indent to first column.
    2              0.000042   if match(line, '^\s*\%(=begin\|=end\)$') != -1
                                return 0
                              endif
                            
                              " If we have a deindenting keyword, find its match and indent to its level.
                              " TODO: this is messy
    2   0.000113   0.000027   if s:Match(clnum, s:ruby_deindent_keywords)
                                call cursor(clnum, 1)
                                if searchpair(s:end_start_regex, s:end_middle_regex, s:end_end_regex, 'bW', s:end_skip_expr) > 0
                                  let msl  = s:GetMSL(line('.'))
                                  let line = getline(line('.'))
                            
                                  if strpart(line, 0, col('.') - 1) =~ '=\s*$' && strpart(line, col('.') - 1, 2) !~ 'do'
                                    " assignment to case/begin/etc, on the same line, hanging indent
                                    let ind = virtcol('.') - 1
                                  elseif g:ruby_indent_block_style == 'do'
                                    " align to line of the "do", not to the MSL
                                    let ind = indent(line('.'))
                                  elseif getline(msl) =~ '=\s*\(#.*\)\=$'
                                    " in the case of assignment to the MSL, align to the starting line,
                                    " not to the MSL
                                    let ind = indent(line('.'))
                                  else
                                    " align to the MSL
                                    let ind = indent(msl)
                                  endif
                                endif
                                return ind
                              endif
                            
                              " If we are in a multi-line string or line-comment, don't do anything to it.
    2   0.009177   0.000067   if s:IsInStringOrDocumentation(clnum, matchend(line, '^\s*') + 1)
                                return indent('.')
                              endif
                            
                              " If we are at the closing delimiter of a "<<" heredoc-style string, set the
                              " indent to 0.
    2              0.000032   if line =~ '^\k\+\s*$' && s:IsInStringDelimiter(clnum, 1) && search('\V<<'.line, 'nbW') > 0
                                return 0
                              endif
                            
                              " If the current line starts with a leading operator, add a level of indent.
    2   0.000091   0.000015   if s:Match(clnum, s:leading_operator_regex)
                                return indent(s:GetMSL(clnum)) + sw
                              endif
                            
                              " 3.3. Work on the previous line. {{{2
                              " -------------------------------
                            
                              " Find a non-blank, non-multi-line string line above the current line.
    2   0.006271   0.000028   let lnum = s:PrevNonBlankNonString(clnum - 1)
                            
                              " If the line is empty and inside a string, use the previous line.
    2              0.000031   if line =~ '^\s*$' && lnum != prevnonblank(clnum - 1)
                                return indent(prevnonblank(clnum))
                              endif
                            
                              " At the start of the file use zero indent.
    2              0.000002   if lnum == 0
                                return 0
                              endif
                            
                              " Set up variables for the previous line.
    2              0.000007   let line = getline(lnum)
    2              0.000006   let ind = indent(lnum)
                            
    2              0.000005   if g:ruby_indent_access_modifier_style == 'indent'
                                " If the previous line was a private/protected keyword, add a
                                " level of indent.
                                if s:Match(lnum, s:indent_access_modifier_regex)
                                  return indent(lnum) + sw
                                endif
                              elseif g:ruby_indent_access_modifier_style == 'outdent'
                                " If the previous line was a private/protected/public keyword, add
                                " a level of indent, since the keyword has been out-dented.
                                if s:Match(lnum, s:access_modifier_regex)
                                  return indent(lnum) + sw
                                endif
                              endif
                            
    2   0.000271   0.000027   if s:Match(lnum, s:continuable_regex) && s:Match(lnum, s:continuation_regex)
                                return indent(s:GetMSL(lnum)) + sw + sw
                              endif
                            
                              " If the previous line ended with a block opening, add a level of indent.
    2   0.000189   0.000011   if s:Match(lnum, s:block_regex)
                                let msl = s:GetMSL(lnum)
                            
                                if g:ruby_indent_block_style == 'do'
                                  " don't align to the msl, align to the "do"
                                  let ind = indent(lnum) + sw
                                elseif getline(msl) =~ '=\s*\(#.*\)\=$'
                                  " in the case of assignment to the msl, align to the starting line,
                                  " not to the msl
                                  let ind = indent(lnum) + sw
                                else
                                  let ind = indent(msl) + sw
                                endif
                                return ind
                              endif
                            
                              " If the previous line started with a leading operator, use its MSL's level
                              " of indent
    2   0.000089   0.000022   if s:Match(lnum, s:leading_operator_regex)
                                return indent(s:GetMSL(lnum))
                              endif
                            
                              " If the previous line ended with the "*" of a splat, add a level of indent
    2              0.000066   if line =~ s:splat_regex
                                return indent(lnum) + sw
                              endif
                            
                              " If the previous line contained unclosed opening brackets and we are still
                              " in them, find the rightmost one and add indent depending on the bracket
                              " type.
                              "
                              " If it contained hanging closing brackets, find the rightmost one, find its
                              " match and indent according to that.
    2              0.000023   if line =~ '[[({]' || line =~ '[])}]\s*\%(#.*\)\=$'
    2   0.001764   0.000030     let [opening, closing] = s:ExtraBrackets(lnum)
                            
    2              0.000002     if opening.pos != -1
                                  if opening.type == '(' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
                                    if col('.') + 1 == col('$')
                                      return ind + sw
                                    else
                                      return virtcol('.')
                                    endif
                                  else
                                    let nonspace = matchend(line, '\S', opening.pos + 1) - 1
                                    return nonspace > 0 ? nonspace : ind + sw
                                  endif
                                elseif closing.pos != -1
                                  call cursor(lnum, closing.pos + 1)
                                  normal! %
                            
                                  if s:Match(line('.'), s:ruby_indent_keywords)
                                    return indent('.') + sw
                                  else
                                    return indent(s:GetMSL(line('.')))
                                  endif
                                else
    2              0.000006       call cursor(clnum, vcol)
    2              0.000002     end
    2              0.000001   endif
                            
                              " If the previous line ended with an "end", match that "end"s beginning's
                              " indent.
    2   0.000159   0.000011   let col = s:Match(lnum, '\%(^\|[^.:@$]\)\<end\>\s*\%(#.*\)\=$')
    2              0.000002   if col > 0
                                call cursor(lnum, col)
                                if searchpair(s:end_start_regex, '', s:end_end_regex, 'bW', s:end_skip_expr) > 0
                                  let n = line('.')
                                  let ind = indent('.')
                                  let msl = s:GetMSL(n)
                                  if msl != n
                                    let ind = indent(msl)
                                  end
                                  return ind
                                endif
                              end
                            
    2   0.000258   0.000012   let col = s:Match(lnum, s:ruby_indent_keywords)
    2              0.000002   if col > 0
                                call cursor(lnum, col)
                                let ind = virtcol('.') - 1 + sw
                                " TODO: make this better (we need to count them) (or, if a searchpair
                                " fails, we know that something is lacking an end and thus we indent a
                                " level
                                if s:Match(lnum, s:end_end_regex)
                                  let ind = indent('.')
                                endif
                                return ind
                              endif
                            
                              " 3.4. Work on the MSL line. {{{2
                              " --------------------------
                            
                              " Set up variables to use and search for MSL to the previous line.
    2              0.000002   let p_lnum = lnum
    2   0.009922   0.000021   let lnum = s:GetMSL(lnum)
                            
                              " If the previous line wasn't a MSL.
    2              0.000004   if p_lnum != lnum
                                " If previous line ends bracket and begins non-bracket continuation decrease indent by 1.
                                if s:Match(p_lnum, s:bracket_switch_continuation_regex)
                                  return ind - 1
                                " If previous line is a continuation return its indent.
                                " TODO: the || s:IsInString() thing worries me a bit.
                                elseif s:Match(p_lnum, s:non_bracket_continuation_regex) || s:IsInString(p_lnum,strlen(line))
                                  return ind
                                endif
                              endif
                            
                              " Set up more variables, now that we know we wasn't continuation bound.
    2              0.000005   let line = getline(lnum)
    2              0.000004   let msl_ind = indent(lnum)
                            
                              " If the MSL line had an indenting keyword in it, add a level of indent.
                              " TODO: this does not take into account contrived things such as
                              " module Foo; class Bar; end
    2   0.000256   0.000011   if s:Match(lnum, s:ruby_indent_keywords)
                                let ind = msl_ind + sw
                                if s:Match(lnum, s:end_end_regex)
                                  let ind = ind - sw
                                endif
                                return ind
                              endif
                            
                              " If the previous line ended with [*+/.,-=], but wasn't a block ending or a
                              " closing bracket, indent one extra level.
    2   0.000321   0.000014   if s:Match(lnum, s:non_bracket_continuation_regex) && !s:Match(lnum, '^\s*\([\])}]\|end\)')
                                if lnum == p_lnum
                                  let ind = msl_ind + sw
                                else
                                  let ind = msl_ind
                                endif
                                return ind
                              endif
                            
                              " }}}2
                            
    2              0.000003   return ind

FUNCTION  airline#util#append()
Called 98 times
Total time:   0.001030
 Self time:   0.001030

count  total (s)   self (s)
   98              0.000211   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   98              0.000289   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
   98              0.000293   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>43_GetMSL()
Called 2 times
Total time:   0.009901
 Self time:   0.000538

count  total (s)   self (s)
                              " Start on the line we're at and use its indent.
    2              0.000003   let msl = a:lnum
    2              0.000005   let msl_body = getline(msl)
    2   0.007805   0.000014   let lnum = s:PrevNonBlankNonString(a:lnum - 1)
    2              0.000004   while lnum > 0
                                " If we have a continuation line, or we're in a string, use line as MSL.
                                " Otherwise, terminate search as we have found our MSL already.
    2              0.000006     let line = getline(lnum)
                            
    2   0.000254   0.000030     if !s:Match(msl, s:backslash_continuation_regex) && s:Match(lnum, s:backslash_continuation_regex)
                                  " If the current line doesn't end in a backslash, but the previous one
                                  " does, look for that line's msl
                                  "
                                  " Example:
                                  "   foo = "bar" \
                                  "     "baz"
                                  "
                                  let msl = lnum
                                elseif s:Match(msl, s:leading_operator_regex)
                                  " If the current line starts with a leading operator, keep its indent
                                  " and keep looking for an MSL.
                                  let msl = lnum
                                elseif s:Match(lnum, s:splat_regex)
                                  " If the above line looks like the "*" of a splat, use the current one's
                                  " indentation.
                                  "
                                  " Example:
                                  "   Hash[*
                                  "     method_call do
                                  "       something
                                  "
                                  return msl
                                elseif s:Match(lnum, s:non_bracket_continuation_regex) && s:Match(msl, s:non_bracket_continuation_regex)
                                  " If the current line is a non-bracket continuation and so is the
                                  " previous one, keep its indent and continue looking for an MSL.
                                  "
                                  " Example:
                                  "   method_call one,
                                  "     two,
                                  "     three
                                  "
                                  let msl = lnum
                                elseif s:Match(lnum, s:dot_continuation_regex) && (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If the current line is a bracket continuation or a block-starter, but
                                  " the previous is a dot, keep going to see if the previous line is the
                                  " start of another continuation.
                                  "
                                  " Example:
                                  "   parent.
                                  "     method_call {
                                  "     three
                                  "
                                  let msl = lnum
                                elseif s:Match(lnum, s:non_bracket_continuation_regex) && (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If the current line is a bracket continuation or a block-starter, but
                                  " the previous is a non-bracket one, respect the previous' indentation,
                                  " and stop here.
                                  "
                                  " Example:
                                  "   method_call one,
                                  "     two {
                                  "     three
                                  "
                                  return lnum
                                elseif s:Match(lnum, s:bracket_continuation_regex) && (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If both lines are bracket continuations (the current may also be a
                                  " block-starter), use the current one's and stop here
                                  "
                                  " Example:
                                  "   method_call(
                                  "     other_method_call(
                                  "       foo
                                  return msl
                                elseif s:Match(lnum, s:block_regex) && !s:Match(msl, s:continuation_regex) && !s:Match(msl, s:block_continuation_regex)
                                  " If the previous line is a block-starter and the current one is
                                  " mostly ordinary, use the current one as the MSL.
                                  "
                                  " Example:
                                  "   method_call do
                                  "     something
                                  "     something_else
                                  return msl
                                else
    2              0.000180       let col = match(line, s:continuation_regex) + 1
    2   0.000495   0.000035       if (col > 0 && !s:IsInStringOrComment(lnum, col)) || s:IsInString(lnum, strlen(line))
                                    let msl = lnum
                                  else
    2              0.000002         break
                                  endif
                                endif
                            
                                let msl_body = getline(msl)
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile
    2              0.000003   return msl

FUNCTION  airline#parts#readonly()
Called 14 times
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
   14              0.000045   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
   14              0.000027     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  airline#util#shorten()
Called 28 times
Total time:   0.000595
 Self time:   0.000595

count  total (s)   self (s)
   28              0.000215   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
                              else
   28              0.000041     return a:text
                              endif

FUNCTION  <SNR>52_get_array()
Called 194 times
Total time:   0.001719
 Self time:   0.001719

count  total (s)   self (s)
  194              0.000708   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  194              0.000894   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  <SNR>52_get_syn()
Called 388 times
Total time:   0.011810
 Self time:   0.011810

count  total (s)   self (s)
  388              0.001076   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
  388              0.000503   let color = ''
  388              0.000958   if hlexists(a:group)
  360              0.002204     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
  360              0.000281   endif
  388              0.000971   if empty(color) || color == -1
                                " should always exists
   30              0.000201     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
   30              0.000063     if empty(color) || color == -1
   30              0.000042       let color = 'NONE'
   30              0.000027     endif
   30              0.000021   endif
  388              0.000396   return color

FUNCTION  airline#themes#get_highlight()
Called 56 times
Total time:   0.007022
 Self time:   0.000414

count  total (s)   self (s)
   56   0.007004   0.000396   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  airline#highlighter#exec()
Called 138 times
Total time:   0.036045
 Self time:   0.011787

count  total (s)   self (s)
  138              0.000251   if pumvisible()
                                return
                              endif
  138              0.000230   let colors = a:colors
  138              0.000178   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  138   0.018114   0.000807   let old_hi = airline#highlighter#get_highlight(a:group)
  138              0.000308   if len(colors) == 4
   32              0.000085     call add(colors, '')
   32              0.000022   endif
  138              0.000227   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
  138              0.001089     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  138              0.000104   endif
  138   0.003134   0.000674   let colors = s:CheckDefined(colors)
  138   0.001345   0.000628   if old_hi != new_hi || !s:hl_group_exists(a:group)
   78   0.006271   0.002497     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg='), s:Get(colors, 1, 'guibg='), s:Get(colors, 2, 'ctermfg='), s:Get(colors, 3, 'ctermbg='), s:Get(colors, 4, 'gui='), s:Get(colors, 4, 'cterm='), s:Get(colors, 4, 'term='))
   78              0.000618     exe cmd
   78              0.000258     if has_key(s:hl_groups, a:group)
   78              0.000187       let s:hl_groups[a:group] = colors
   78              0.000061     endif
   78              0.000058   endif

FUNCTION  <SNR>48_ws_refresh()
Called 1 time
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000015   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    1              0.000003     return
                              endif
                              unlet! b:airline_whitespace_check
                              if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
                              let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>43_Match()
Called 36 times
Total time:   0.002709
 Self time:   0.002709

count  total (s)   self (s)
   36              0.000106   let line   = getline(a:lnum)
   36              0.002006   let offset = match(line, '\C'.a:regex)
   36              0.000091   let col    = offset + 1
                            
   36              0.000113   while offset > -1 && s:IsInStringOrComment(a:lnum, col)
                                let offset = match(line, '\C'.a:regex, offset + 1)
                                let col = offset + 1
                              endwhile
                            
   36              0.000051   if offset > -1
                                return col
                              else
   36              0.000027     return 0
                              endif

FUNCTION  <SNR>44_sync_active_winnr()
Called 2 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000014   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  <SNR>49_wordcount_update()
Called 6 times
Total time:   0.000374
 Self time:   0.000374

count  total (s)   self (s)
    6              0.000022   if empty(bufname(''))
                                return
                              endif
    6              0.000163   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick ||  get(b:, 'airline_winwidth', 0) != winwidth(0)
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                    let b:airline_winwidth = winwidth(0)
                                  endif
                                endif
                              endif

FUNCTION  airline#highlighter#get_highlight()
Called 194 times
Total time:   0.023915
 Self time:   0.010386

count  total (s)   self (s)
  194              0.000775   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                return s:hl_groups[a:group]
                              else
  194   0.007222   0.001098     let fg = s:get_syn(a:group, 'fg')
  194   0.006654   0.000968     let bg = s:get_syn(a:group, 'bg')
  194              0.002541     let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  194              0.000890     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  194              0.000288     let opts = a:000
  194              0.000218     if bold
   29              0.000048       let opts = ['bold']
   29              0.000017     endif
  194   0.003127   0.001408     let res = reverse ? s:get_array(bg, fg, opts) : s:get_array(fg, bg, opts)
  194              0.000158   endif
  194              0.000562   let s:hl_groups[a:group] = res
  194              0.000205   return res

FUNCTION  airline#parts#paste()
Called 14 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
   14              0.000037   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#util#wrap()
Called 84 times
Total time:   0.000544
 Self time:   0.000544

count  total (s)   self (s)
   84              0.000234   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   84              0.000102   return a:text

FUNCTION  airline#extensions#keymap#status()
Called 14 times
Total time:   0.000175
 Self time:   0.000175

count  total (s)   self (s)
   14              0.000085   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   14              0.000076     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  airline#parts#iminsert()
Called 14 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
   14              0.000038   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
   14              0.000014   return ''

FUNCTION  airline#check_mode()
Called 14 times
Total time:   0.051926
 Self time:   0.001759

count  total (s)   self (s)
   14              0.000065   if !exists("s:airline_run")
                                let s:airline_run = 0
                              endif
   14              0.000039   let s:airline_run += 1
                            
   14              0.000043   let context = s:contexts[a:winnr]
                            
   14              0.000052   if get(w:, 'airline_active', 1)
   14              0.000042     let l:m = mode()
   14              0.000032     if l:m ==# "i"
    6              0.000013       let l:mode = ['insert']
    6              0.000006     elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
    8              0.000019       let l:mode = ['normal']
    8              0.000007     endif
   14              0.000096     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   14              0.000013   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
   14              0.000042   if g:airline_detect_modified && &modified
   14              0.000057     call add(l:mode, 'modified')
   14              0.000012   endif
                            
   14              0.000025   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
   14              0.000065   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
   14              0.000031   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
   14              0.000024   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
   14              0.000093   let mode_string = join(l:mode)
   14              0.000024   if s:airline_run < 3
                                " skip this round.
                                " When this function is run too early after startup,
                                " it forces a redraw by vim which will remove the intro screen.
                                let w:airline_lastmode = mode_string
                                return ''
                              endif
   14              0.000057   if get(w:, 'airline_lastmode', '') != mode_string
    2   0.000847   0.000039     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    2   0.049405   0.000046     call airline#highlighter#highlight(l:mode, context.bufnr)
    2              0.000005     let w:airline_lastmode = mode_string
    2              0.000002   endif
                            
   14              0.000015   return ''

FUNCTION  airline#extensions#syntastic#get()
Called 28 times
Total time:   0.005792
 Self time:   0.000950

count  total (s)   self (s)
   28              0.000120   let _backup = get(g:, 'syntastic_stl_format', '')
   28              0.000074   let is_err = (a:type  is# 'error')
   28              0.000032   if is_err
   14              0.000060     let g:syntastic_stl_format = get(g:, 'airline#extensions#syntastic#stl_format_err', '%E{[%e(#%fe)]}')
   14              0.000013   else
   14              0.000065     let g:syntastic_stl_format = get(g:, 'airline#extensions#syntastic#stl_format_warn', '%W{[%w(#%fw)]}')
   14              0.000013   endif
   28   0.005001   0.000159   let cnt = SyntasticStatuslineFlag()
   28              0.000071   if !empty(_backup)
   28              0.000065     let g:syntastic_stl_format = _backup
   28              0.000020   endif
   28              0.000057   if empty(cnt)
   28              0.000027     return ''
                              else
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt
                              endif

FUNCTION  syntastic#util#getbufvar()
Called 28 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
   28              0.000187     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)

FUNCTION  airline#parts#spell()
Called 14 times
Total time:   0.000417
 Self time:   0.000417

count  total (s)   self (s)
   14              0.000191   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   14              0.000026   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
   14              0.000013   return ''

FUNCTION  <SNR>43_IsInStringOrComment()
Called 12 times
Total time:   0.014787
 Self time:   0.014787

count  total (s)   self (s)
   12              0.014781   return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_strcom

FUNCTION  <SNR>43_IsInStringOrDocumentation()
Called 2 times
Total time:   0.009110
 Self time:   0.009110

count  total (s)   self (s)
    2              0.009109   return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_stringdoc

FUNCTION  airline#parts#crypt()
Called 14 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
   14              0.000081   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#whitespace#check()
Called 14 times
Total time:   0.001878
 Self time:   0.001560

count  total (s)   self (s)
   14              0.000059   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   14              0.000094   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
                            
   14              0.000047   if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                if index(checks, 'trailing') > -1
                                  try
                                    let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    echomsg 'airline#whitespace: error occured evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                  endif
                                endif
                              endif
   14   0.000395   0.000077   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  SyntasticStatuslineFlag()
Called 28 times
Total time:   0.004842
 Self time:   0.000489

count  total (s)   self (s)
   28   0.004829   0.000476     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  airline#extensions#syntastic#get_warning()
Called 14 times
Total time:   0.003270
 Self time:   0.000116

count  total (s)   self (s)
   14   0.003262   0.000108   return airline#extensions#syntastic#get('warning')

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 2 times
Total time:   0.000808
 Self time:   0.000091

count  total (s)   self (s)
    2              0.000009   if getbufvar(a:bufnr, '&modified')
    2              0.000022     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    2              0.000002   else
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
                              endif
                            
    2              0.000004   if !empty(colors)
    2   0.000754   0.000037     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    2              0.000002   endif

FUNCTION  <SNR>52_hl_group_exists()
Called 60 times
Total time:   0.000717
 Self time:   0.000717

count  total (s)   self (s)
   60              0.000178   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
   60              0.000043   return 1

FUNCTION  <SNR>52_Get()
Called 546 times
Total time:   0.003774
 Self time:   0.003774

count  total (s)   self (s)
  546              0.001418   let res=get(a:dict, a:key, '')
  546              0.000777   if res is ''
  228              0.000221     return ''
                              else
  318              0.000539     return a:prefix. res
                              endif

FUNCTION  <SNR>43_ExtraBrackets()
Called 2 times
Total time:   0.001734
 Self time:   0.000720

count  total (s)   self (s)
    2              0.000011   let opening = {'parentheses': [], 'braces': [], 'brackets': []}
    2              0.000007   let closing = {'parentheses': [], 'braces': [], 'brackets': []}
                            
    2              0.000004   let line = getline(a:lnum)
    2              0.000025   let pos  = match(line, '[][(){}]', 0)
                            
                              " Save any encountered opening brackets, and remove them once a matching
                              " closing one has been found. If a closing bracket shows up that doesn't
                              " close anything, save it for later.
   10              0.000015   while pos != -1
    8   0.001065   0.000051     if !s:IsInStringOrComment(a:lnum, pos + 1)
    8              0.000027       if line[pos] == '('
    2              0.000010         call add(opening.parentheses, {'type': '(', 'pos': pos})
    2              0.000003       elseif line[pos] == ')'
    2              0.000005         if empty(opening.parentheses)
                                      call add(closing.parentheses, {'type': ')', 'pos': pos})
                                    else
    2              0.000009           let opening.parentheses = opening.parentheses[0:-2]
    2              0.000001         endif
    2              0.000002       elseif line[pos] == '{'
    2              0.000013         call add(opening.braces, {'type': '{', 'pos': pos})
    2              0.000003       elseif line[pos] == '}'
    2              0.000004         if empty(opening.braces)
                                      call add(closing.braces, {'type': '}', 'pos': pos})
                                    else
    2              0.000007           let opening.braces = opening.braces[0:-2]
    2              0.000002         endif
    2              0.000002       elseif line[pos] == '['
                                    call add(opening.brackets, {'type': '[', 'pos': pos})
                                  elseif line[pos] == ']'
                                    if empty(opening.brackets)
                                      call add(closing.brackets, {'type': ']', 'pos': pos})
                                    else
                                      let opening.brackets = opening.brackets[0:-2]
                                    endif
                                  endif
    8              0.000005     endif
                            
    8              0.000118     let pos = match(line, '[][(){}]', pos + 1)
    8              0.000009   endwhile
                            
                              " Find the rightmost brackets, since they're the ones that are important in
                              " both opening and closing cases
    2              0.000006   let rightmost_opening = {'type': '(', 'pos': -1}
    2              0.000005   let rightmost_closing = {'type': ')', 'pos': -1}
                            
    2              0.000008   for opening in opening.parentheses + opening.braces + opening.brackets
                                if opening.pos > rightmost_opening.pos
                                  let rightmost_opening = opening
                                endif
                              endfor
                            
    2              0.000006   for closing in closing.parentheses + closing.braces + closing.brackets
                                if closing.pos > rightmost_closing.pos
                                  let rightmost_closing = closing
                                endif
                              endfor
                            
    2              0.000005   return [rightmost_opening, rightmost_closing]

FUNCTION  <SNR>43_PrevNonBlankNonString()
Called 4 times
Total time:   0.014034
 Self time:   0.000261

count  total (s)   self (s)
    4              0.000005   let in_block = 0
    4              0.000010   let lnum = prevnonblank(a:lnum)
    4              0.000008   while lnum > 0
                                " Go in and out of blocks comments as necessary.
                                " If the line isn't empty (with opt. comment) or in a string, end search.
    4              0.000010     let line = getline(lnum)
    4              0.000016     if line =~ '^=begin'
                                  if in_block
                                    let in_block = 0
                                  else
                                    break
                                  endif
                                elseif !in_block && line =~ '^=end'
                                  let in_block = 1
                                elseif !in_block && line !~ '^\s*#.*$' && !(s:IsInStringOrComment(lnum, 1) && s:IsInStringOrComment(lnum, strlen(line)))
    4              0.000011       break
                                endif
                                let lnum = prevnonblank(lnum - 1)
                              endwhile
    4              0.000006   return lnum

FUNCTION  <SNR>52_CheckDefined()
Called 138 times
Total time:   0.002460
 Self time:   0.002460

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  138              0.000448   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
  138              0.000447   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
  138              0.000214     return a:colors
                              endif
                            
                              for val in a:colors
                                if !empty(val) && val !=# 'NONE'
                                  return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  airline#extensions#syntastic#get_error()
Called 14 times
Total time:   0.002740
 Self time:   0.000102

count  total (s)   self (s)
   14   0.002731   0.000093   return airline#extensions#syntastic#get('error')

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   14   0.051926   0.001759  airline#check_mode()
    2   0.049359   0.005937  airline#highlighter#highlight()
  138   0.036045   0.011787  airline#highlighter#exec()
    2   0.029759   0.001174  GetRubyIndent()
  194   0.023915   0.010386  airline#highlighter#get_highlight()
   12   0.014787             <SNR>43_IsInStringOrComment()
   28   0.014348   0.001072  <SNR>52_exec_separator()
    4   0.014034   0.000261  <SNR>43_PrevNonBlankNonString()
  388   0.011810             <SNR>52_get_syn()
    2   0.009901   0.000538  <SNR>43_GetMSL()
    2   0.009110             <SNR>43_IsInStringOrDocumentation()
   56   0.007022   0.000414  airline#themes#get_highlight()
   28   0.005792   0.000950  airline#extensions#syntastic#get()
   28   0.004842   0.000489  SyntasticStatuslineFlag()
  546   0.003774             <SNR>52_Get()
   14   0.003270   0.000116  airline#extensions#syntastic#get_warning()
   14   0.002740   0.000102  airline#extensions#syntastic#get_error()
   36   0.002709             <SNR>43_Match()
  138   0.002460             <SNR>52_CheckDefined()
   28   0.002247   0.000825  39()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   12              0.014787  <SNR>43_IsInStringOrComment()
  388              0.011810  <SNR>52_get_syn()
  138   0.036045   0.011787  airline#highlighter#exec()
  194   0.023915   0.010386  airline#highlighter#get_highlight()
    2              0.009110  <SNR>43_IsInStringOrDocumentation()
    2   0.049359   0.005937  airline#highlighter#highlight()
  546              0.003774  <SNR>52_Get()
   36              0.002709  <SNR>43_Match()
  138              0.002460  <SNR>52_CheckDefined()
   28              0.002106  48()
   14   0.051926   0.001759  airline#check_mode()
  194              0.001719  <SNR>52_get_array()
   14   0.001878   0.001560  airline#extensions#whitespace#check()
   11              0.001366  <SNR>33_Highlight_Matching_Pair()
   28              0.001220  38()
    2   0.029759   0.001174  GetRubyIndent()
   28   0.014348   0.001072  <SNR>52_exec_separator()
   98              0.001030  airline#util#append()
   28   0.005792   0.000950  airline#extensions#syntastic#get()
   28   0.002247   0.000825  39()

